import com.squareup.javapoet.*;
import javax.lang.model.element.Modifier;

buildscript {
	repositories {
		mavenCentral()
	}
	dependencies {
		classpath 'com.squareup:javapoet:1.0.0'
	}
}

apply from: 'attr-quirks.gradle'

task generateAttrs(type: AttrsGeneratorTask)

class AttrsGeneratorTask extends DefaultTask {

	// Most practical API versions according to Android Dashboards:
	// - newer then API level 10 (GB 2.3.3, 99.6% of devices)
	// - newer than API level 15 (ICS 4.0.3, 92.7% of devices)

	def apiLevels = [10, 15]

	@TaskAction
	generate() {
		for (api in apiLevels) {
			def builder = TypeSpec.classBuilder("Attrs")
				.addJavadoc("Factory methods to modify view attributes.\n"
					+ "This file was generated by {@code gradle generateAttrs}\n")
				.addModifiers(Modifier.PUBLIC)
				.superclass(ClassName.get("trikita.anvil.v${api}", "V${api}Attrs"))

			generateFromJar(builder, getAndroidJar(api))

			JavaFile.builder("trikita.anvil.v${api}", builder.build())
				.build()
				.writeTo(new File("src/main/java"))
		}
	}

	@groovy.transform.EqualsAndHashCode
	class MethodKey {
		String method
		Class cls
		MethodKey(m, c) {
			method = m
			cls = c
		}
	}

	def getAndroidJar(api) {
		def rootDir = project.rootDir
    def localProperties = new File(rootDir, "local.properties")
		def sdkDir = ""
    if (localProperties.exists()) {
        Properties properties = new Properties()
        localProperties.withInputStream { instr -> properties.load(instr) }
        sdkDir = properties.getProperty('sdk.dir')
		}
		return new File(sdkDir + "/platforms/android-" + api + "/android.jar")
	}

	def generateFromJar(builder, jarFile) {
		def methods = [:]
		def jar = new java.util.jar.JarFile(jarFile)
		def url = new java.net.URL("jar", "","file:" + jarFile.getAbsolutePath() +"!/")
		def loader = new java.net.URLClassLoader([url] as java.net.URL[], getClass().getClassLoader())
		def viewClass = loader.loadClass("android.view.View")

    for (e in Collections.list(jar.entries())) {
			if (e.getName().endsWith(".class")) {
				def className = e.getName().replace(".class", "").replace("/", ".")
				if (className.contains('$')) {
					// Skip inner classes
					continue;
				}
				def c = loader.loadClass(className);
				if (viewClass.isAssignableFrom(c)) {
					methods = generateFromClass(methods, c)
				}
			}
		}

		methods.sort { it.key.method }.each {
			def attr = TypeSpec.anonymousClassBuilder("arg")
				.superclass(ClassName.get("trikita.anvil", "SimpleAttrNode"))
				.addMethod(it.value.build())
			def param = ParameterSpec.builder(it.key.cls, "arg")
				.addModifiers(Modifier.FINAL)
				.build();
			def factory = MethodSpec.methodBuilder(it.key.method)
				.addModifiers(Modifier.PUBLIC, Modifier.STATIC)
				.addParameter(param)
				.returns(ClassName.get("trikita.anvil", "Nodes", "AttrNode"))
				.addStatement("return \$L", attr.build())
			builder.addMethod(factory.build())
		}
	}

	def generateFromClass(methods, c) {
		def builder, key, name
		for (m in c.getDeclaredMethods()) {
			if (!java.lang.reflect.Modifier.isPublic(m.getModifiers()) || m.isSynthetic() || m.isBridge()) {
				continue
			}
			if (m.getName().matches('^setOn.*Listener$')) {
				name = m.getName()
				name = name.substring(5, name.length() - 8)
				key = new MethodKey("on"+name, m.getParameterTypes()[0]);
				builder = listener(methods.get(key), m)
			} else if (m.getName().startsWith('set') && m.getParameterCount() == 1) {
				name = Character.toLowerCase(m.getName().charAt(3)).toString() + m.getName().substring(4)
				key = new MethodKey(name, m.getParameterTypes()[0]);
				builder = setter(methods.get(key), m)
			} else {
				continue
			}
			if (builder) {
				methods.put(key, builder)
			}
		}
		return methods
	}

	def listener(builder, m) {
		if (!builder) {
			builder = MethodSpec.methodBuilder("apply")
				.addModifiers(Modifier.PUBLIC)
				.addParameter(ClassName.get("android.view", "View"), "v")
		}

		def className = m.getDeclaringClass().getCanonicalName();
		def listenerClass = m.getParameterTypes()[0];

		def listener = TypeSpec.anonymousClassBuilder("")
			.addSuperinterface(listenerClass)
		listenerClass.getDeclaredMethods().each { lm ->
			def methodBuilder = MethodSpec.methodBuilder(lm.getName())
				.addModifiers(Modifier.PUBLIC)
				.returns(lm.getReturnType())

			def args = ""
			lm.getParameterTypes().eachWithIndex { v, i ->
				methodBuilder.addParameter(v, "a${i}")
				args += (i != 0 ? ", " : "") + "a${i}"
			}

			if (lm.getReturnType().equals(Void.TYPE)) {
				methodBuilder
					.addStatement("arg.\$L(${args})", lm.getName())
					.addStatement("\$T.render()", ClassName.get("trikita.anvil", "Anvil"))
			} else {
				methodBuilder
					.addStatement("\$T r = arg.\$L(${args})",
						lm.getReturnType(), lm.getName())
					.addStatement("\$T.render()", ClassName.get("trikita.anvil", "Anvil"))
					.addStatement("return r")
			}

			listener.addMethod(methodBuilder.build())
		}

		builder
			.beginControlFlow("if (v instanceof ${className})")
			.addStatement("((${className}) v).${m.getName()}(\$L)", listener.build())
			.endControlFlow();

		return builder
	}

	def setter(builder, m) {
		if (!builder) {
			builder = MethodSpec.methodBuilder("apply")
				.addModifiers(Modifier.PUBLIC)
				.addParameter(ClassName.get("android.view", "View"), "v")
		}

		def className = m.getDeclaringClass().getCanonicalName();
		if (project.QUIRKS[className]
			&& project.QUIRKS[className][m.getName()]) {
			return project.QUIRKS[className][m.getName()](builder)
		}
		builder
			.beginControlFlow("if (v instanceof \$T)", m.getDeclaringClass())
			.addStatement("((\$T) v).${m.getName()}(arg)", m.getDeclaringClass())
			.endControlFlow();

		return builder
	}
}

